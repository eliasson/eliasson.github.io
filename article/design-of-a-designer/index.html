<!DOCTYPE html>
<html xmlns="//www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="/eliasson.css" />
    

    
        <title>The Design of a Designer at Markus Eliasson</title>
    

    <script defer src="https://api.pirsch.io/pa.js" id="pianjs" data-code="t6zLGwH2S4qPWg5EY6RnU5Xg0af5aztT"></script>
</head>




<body>
    <header>
    <div class="logo">
        <a href="https://markuseliasson.se">M<span class="is-red-period">.</span>E<span class="is-red-period">.</span></a>
    </div>
</header>


    <article>
        <h1>The Design of a Designer</h1>
        <p class="preamble">Here is a walkthrough of the software design of a construction design tool I have been working on lately. It is a long read, focusing on the user interaction of such a tool in a complex domain, together with the benefits and challenges of this design. I always enjoy reading about how a piece of software is designed, the rationale behind the decisions, etc. This article is my way of giving back.</p>
        <time>Tuesday, September 3, 2024</time>

        <section>
            <p>I recently had the great opportunity to be part of a team that developed a piece of software that enabled users to
design constructions of a certain type, while following product rules and recommendations from the manufacturer.</p>
<p>The client operates in a construction type of domain where they produce a whole range of products that need to be
assembled in order to provide a solution for their customer’s needs. They have websites, catalogs and clear assembly
instructions detailing which pieces that are compatible and how to fit things together.</p>
<p>Our task was to build a web application where their customers could design their solutions using said company’s products.</p>
<blockquote>
<p>We need you to build a new drawing program for us.</p>
</blockquote>
<p>Why on earth would anyone build their own design tool? Is it not enough to rely on existing CAD software?</p>
<h2 id="computer-aided-design">Computer Aided Design</h2>
<p>Most CAD software are highly advanced 3D-modeling tools.
<span class="sidenote">
    <img src="/designer/picoCAD.jpg" alt="picoCAD" /><a class="no-feedback" href="https://johanpeitz.itch.io/picocad" target="_new">The fabulous picoCAD</a>
</span>

They provide incredible levels of details, simulations, stress analysis, integrations to product data and a long list
of other features.</p>
<p>CAD tools are also aimed at technical people that care about most of those details. The tool we were asked to develop
is both a technical tool and a sales tool. The target audience for said tool might very well be in charge of both the
purchase and assembly of the products sold.</p>
<p>One might argue that such a tool is still a Computer Aided Design tool, but it is not really what most people would
consider a <em>“CAD-tool”</em>.</p>
<h2 id="objectives">Objectives</h2>
<p>Given the conclusion that the design software is as much a sales tool as a technical tool we set out with the following
objectives in our project:</p>
<p><strong>Users should not have to be product experts</strong> - Users are experts in their own domain, they use products to help them
solve a particular problem of theirs. They do not know all the details about them and they most likely do not have the
time or interest to learn it. And I believe it is safe to assume that most users are not frequent users of the system.</p>
<p><strong>If it can be designed it can be built</strong> - the tool should guide the users to design solutions where parts are
correctly combined using best practices. Invalid constructions should not be possible to design.</p>
<p>It must scale - the tool should scale from beginners to power users, independently of the sales organization.
Onboarding of new users should not require dedicated training.</p>
<h2 id="domain">Domain</h2>
<p>As you might have noticed I have stayed away from naming our client and their specific domain.
<span class="sidenote">
    <img src="/designer/our-domain.png" alt="Our domain" />Our domain, old school power lines.
</span>

It is not relevant for this article and instead the examples used to illustrate the design will be generic. Let’s pretend we’re about to
develop a software to design a system of old school overhead power lines.</p>
<ul>
<li>There are multiple types of posts; wood and steel.</li>
<li>There are different heights for posts, 9 and 12 meters.</li>
<li>There are two types of wiring between the posts; iron and steel.</li>
</ul>
<h2 id="design-principles">Design principles</h2>
<p>The team building this software relied on the following principles during the development of the program.</p>
<ul>
<li>All code must be tested, everyone on the team has been using Test Driven Development for many years.</li>
<li>Product data should be imported to the application.</li>
<li>Product rules should not be hard-coded but modeled as part of the product data or expressed next to it.</li>
<li>Domain logic should be kept out from any rendering.</li>
</ul>
<p>While not clearly defined at the start of the project these principles were already agreed upon by the team from earlier
projects and a long history of using <strong>Domain Driven Design</strong>, <strong>Extreme Programming</strong> and <strong>Test-Driven Development</strong>.</p>
<p>For readers unfamiliar with these concepts, the reasons are:</p>
<ul>
<li>Domain experts should define the data and properties of products as they know it best.</li>
<li>Product lifecycle and additions should not require software development.</li>
<li>Rendering UI, drawings, etc. should be separated from domain logic to allow for independent changes and life cycles.</li>
<li>TDD gives us a sound design as well as confidence to change and improve the software for years to come.</li>
</ul>
<h2 id="architecture-and-software-design">Architecture and software design</h2>
<p>The architecture is pretty standard, there is a front-end and a back-end service.</p>

<div class="fullwidth">
    <img src="/designer/overview.png" alt="Architecture overview" />
</div>


<p>The responsibility between these parts is that the back-end is responsible for:</p>
<ul>
<li>Authenticate via OpenID Connect</li>
<li>Store product data.</li>
<li>Integrate with an external system to handle orders and quotation requests.</li>
<li>Export the design of a project to</li>
<li>2D drawing.</li>
<li>3D model.</li>
<li>Bill of material.</li>
</ul>
<p>The front-end is where the user designs a solution in a 2D canvas with 3D rendering as a companion view. And where the
user initiates the actions to order and to export the drawing in various formats.</p>
<p>We chose to make the application front-end heavy<span class="note">1</span>
 in order to get as snappy interactions as possible.
The rest of the article will focus on the front-end parts and pieces.
<span class="sidenote">
    1. In responsibility, not in bytes.
</span>
</p>
<h2 id="user-interaction">User interaction</h2>
<p>Remember that the UI should not implement any domain logic? We decided that the UI should only do at most three things:</p>
<ul>
<li>Render drawing items (e.g. post and wires).</li>
<li>Showing the user possible actions that can be taken (e.g. place post, delete post).</li>
<li>Trigger actions initiated by the user.</li>
</ul>
<p>However, the UI should not itself decide which actions are available, nor should it have to handle situations where an
initiated action could not be performed. Getting the last part right is important, as it is a very frustrating user
experience when you try to do something and first after you initiate an action the system lets you know that it is not
currently possible.</p>
<p>The solution we chose is that the UI asks the program what options should be made available, and these options contain
a command that can be executed if the user should choose to select it.</p>
<h2 id="creating-a-tiny-route">Creating a tiny route</h2>
<p>Imagine that you are about to design a simple electricity route.</p>
<ul>
<li>You start off with nothing and drag-and-drop a post onto a canvas from a toolbox.</li>
<li>You click to focus on the newly added post and arrows in all four directions appear.</li>
<li>When you click the right arrow a new post is added with wires connected to the first post. The new post has three
arrows present, and you select the bottom one.</li>
<li>Yet another post is added, also with wiring to its previous post. The previous post is automatically rotated 45
degrees to form a corner.</li>
</ul>

<div class="fullwidth">
    <img src="/designer/tiny-route.png" alt="Designing a tiny route" />
</div>


<h2 id="step-by-step-walkthrough">Step-by-step walkthrough</h2>
<p>Let us walk through this step by step.</p>
<p>Skipping the initial post, here is a simplified diagram on what happens when a user selects a post and acts on one of
the arrows presented (i.e. the transition from image 2 to 3).</p>

<div class="fullwidth">
    <img src="/designer/step-by-step.png" alt="Step by step" />
</div>


<p>When the user selects the post, the 2D shape renderer will ask the <code>SolutionWorkingSet</code> which options are available (1).
Option are modeled as <code>CommandOption</code>, each represents a single option with meta-data such as:</p>
<ul>
<li><strong>Type</strong>, if this represents an action, movement, menu item, keyboard, etc.</li>
<li><strong>Label</strong>, used if this option is displayed as a menu item.</li>
<li><strong>Command</strong>, if this option is selected by the user, there is a pre-constructed command that should be executed. This
command is fully constructed and <code>CommandOption</code> will never be created with a command that cannot be executed.</li>
</ul>
<p>In our example four arrows were presented for the user. These are represented by four different <code>CommandOption</code>, one for
each direction. The type of these options will be of the type action, it has a label that can be used as tooltip by the
2D renderer and carry a command of the type <code>ExtendFromPost</code> that will be executed upon the user clicking the arrow
(action).</p>
<p>These options are given to the 2D renderer that displays each option as a blue arrow, which is determined by the type
and command in this case.</p>
<h3 id="identifying-available-options">Identifying available options</h3>
<p>Later in the illustration (screenshot 4), the user selects another post where only three arrows (options) are present.
While this is obvious for a highly trained electricity planner such as yourself, the program still needs to have some
way of determining the available options should only be for three directions, since one is already in use.</p>
<p>The chosen approach for this is to combine the following into something we refer to as the <code>RuleEngine</code>.</p>
<ul>
<li><strong>A rich domain model</strong> - a post can tell how many available connections that are available (among other things).</li>
<li><strong>Product data</strong> - which posts and wires are compatible with each other.</li>
</ul>
<p>The <code>RuleEngine</code> implements methods to get the available alternatives for specific situations, e.g. to get the available
extensions from a post. These alternatives are not just the direction, they contain all the changes that need to be
made in order to fulfill the alternative.</p>
<p>In the case of extending the electricity route into the available directions it includes:</p>
<ul>
<li>The new wires between the both posts.</li>
<li>The new post.</li>
<li>A post to replace the originating post with wires attached to it.</li>
</ul>
<p>All items are fully constructed, have the correct position for each alternative, and all alternatives are possible to
execute.</p>
<p>Below is a pseudocode<span class="note">2</span>
 implementation of how such a method is implemented in the <code>RuleEngine</code>.
<span class="sidenote">
    2. A love child between Scala and TypeScript.
</span>
</p>
<pre tabindex="0"><code>def availableExtensionsFromPost(post, world, preferences) =
    for connection in post.availableConnections():
        // As the originating post will be muted (with wiring)
        // for each alternative, a clone is needed 
        val originatingPost = post.clone()
        
        // Calculate where the new post will be positioned.
        // This is based on the originating post&#39;s position
        // the direction (e.g north, east, south, west) and the user
        // preferences on center-to-center distance
        val newPostPosition = calculateNewPostPosition(
            originatingPost.position,
            connection.direction,
            preferences)        
        
        // Create the new post together with the wires to add 
        val newPost = Post(newPostPosition)
        val wire = Wires(Position.Zero)

        // If the new route intersects / collides with any
        // existing wiring this alternative should be skipped
        if world.intersects([wire, newPost]):
            continue

        // The result contains a replacement post (with the wiring
        // attached) and the new items.
        // The point of interest will later be used to render the 
        // option arrows in the UI.
        yield ExtendResult(
            replacements = [originatingPost],
            added = [newPost, wires],
            pointOfInterest = post.position) 
</code></pre><p>As illustrated in the code above, the <code>RuleEngine</code> is responsible to ensure that each alternative is viable. The
alternative where the new wires would intersect with something existing is not a valid alternative and not included
in the result.</p>
<p>The <code>RuleEngine</code> handles what is possible to do and what items of the world that will be affected. It is the
<code>SolutionWorkingSet</code> that is the glue between the graphical representation and the domain model.</p>
<p>The above method would have been called when the user selects the post item in the 2D rendering. Where the UI will call
<code>SolutionWorkingSet.optionsForItem</code> to get the options to render.</p>
<pre tabindex="0"><code>def *optionsForItem(id) =
    val item = this.world.byId(id)
    
    // Use our method to get the possible alternatives for extensions
    val alternatives = this.ruleEngine.availableExtensionsFromPost(
      item, 
      this.world. 
      this.preferences)
      
    for alt in alternatives:
        // Create the command that will be executed if the user selects
        // this option.
        // Each command has different needs, this one will only need to
        // replace one post and add the new items to the world upon execution.
        val command = ExtendFromPostCommand(alt.replacement, alt.added)
        
        // Return an option that should be rendered as an Action at the given position
        yield Option(type = Action, position = alt.pointOfInterest, command))
</code></pre><h3 id="executing-commands">Executing commands</h3>
<p>Now that the UI has received the options available it needs to show them somehow. In our case each option represents a
possible direction, which is illustrated with a blue arrow.</p>
<p><img src="/designer/executing-command.png" alt="Executing a command"></p>
<p>The renderer code that generates the UI above upon a post selection looks something like this:</p>
<pre tabindex="0"><code>// Method called when user selects a post
def showOptions(itemId) =
    val options = this.workingSet.optionsForItem(itemId)
    for option in options:
        if (option.type == Action)
            // Create the UI ornament that should execute the command
            // when acted upon
            val ornament = BlueArrow(
                position = option.position,
                onClick = this.workingSet.execute(option.command))
            this.canvas.add(ornament)
</code></pre><p>As you can see the UI is quite “dumb”, it will only get available options, filter out the relevant ones and then create
the UI control that should be used to represent it.</p>
<p>Again, the available options only return viable options and the commands are already constructed; the code needed to
implement the “action handler” when a blue arrow is clicked is very simple, it just executes the command.</p>
<p>When the user clicks the arrow the command is executed by calling the <code>SolutionWorkingSet.execute</code>:</p>
<pre tabindex="0"><code>def executeCommand(command):
    // Handle the undo and redo stack 
    updateUndoStack()
    
    // To ensure that the command does not alter the world
    // directly make a copy that we later throw away
    val world = this.world.clone()
    
    // Execute the specific command
    val executionResult = command.execute(world)
    
    // Update the world with any new, updated or removed items 
    this.world.update(executionResult)

    // Generate the instructions on what is needed to render
    // (add, update, delete) and perform a partial re-render of
    // the view
    val renderInstructions = this.createRenderInstructions(executionResult)
    this.renderer.rerender(renderInstructions)
</code></pre><p>The <code>SolutionWorkingSet</code> is orchestrating the command execution, handling things like the undo/redo stack and generates
instructions on what to render based on the result of the command execution (to avoid re-render the entire drawing).</p>
<p>Each command is responsible for carrying out the work needed and returning a result.</p>
<p>The command in our example, <code>ExtendFromPostCommand</code> was constructed using the alternative from <code>RuleEngine</code> as
previously  shown in <code>optionsForItem</code>. The replacement post and list of added items were simply given as constructor
arguments to the command, <code>ExtendFromPostCommand(alt.replacement, alt.added)</code>.</p>
<p>The implementation of the command execution is something like:</p>
<pre tabindex="0"><code>def execute(world) =
    // The command constructor was given the items to replace and add
    val newPost = this.added.posts.single()
    val wire = this.added.wires.single()
    
    // Connect the wires between the posts, this will set correct
    // positionings, etc.
    wire.wire(this.replacement, newPost) 
    
    return CommandExecutionResult(
        added = [newPost, wire],
        updated = [this.replacement]
        deleted = [])
</code></pre><p>This is a simple command, the RuleEngine has already constructed all the items needed. The command only needs to connect
the wiring between the posts in order to set the positions and attach the wire to each post.</p>
<h3 id="result-of-executing-a-command">Result of executing a command</h3>
<p>All commands return a <code>CommandExecutionResult</code>, that contains:</p>
<ul>
<li>What was added to the world.</li>
<li>What was updated in the world.</li>
<li>The ID:s of any items that have been removed from the world.</li>
</ul>
<p>This result is then used by the <code>SolutionWorkingSet</code> to update the world with any changes, and then to generate
rendering  instructions for the same set of changes. As we wanted to ensure that no command manipulates the world
directly we make  a clone of the world which is given to the command. Then, by updating the world with the execution
result we can be  certain that the result contains all updates made.</p>
<p>The render instructions are more or less view-model representations of the <code>CommandExecutionResult</code>, allowing our
renderer to only update the items that were changed.</p>
<p>I will not cover how the rendering was done in detail but the gist is that all items that are to be rendered have a
view-model representation. This is to ensure that the renderer cannot access or manipulate any model details directly,
as well as having a model optimized for rendering.</p>
<p>Each view model is represented by a shape, which in turn is constructed by a set of primitives such as line, rectangle,
arc, text, etc. These are laid out in a structure that makes it easy to index an item&rsquo;s shape by the item ID which
allows for fast rendering or removal of items.</p>
<h2 id="that-is-all-there-is">That is all there is</h2>
<p>At a simplified level, this is it.</p>
<p>Let’s recap before we dive into the strengths and weaknesses of this design.</p>

<div class="fullwidth">
    <img src="/designer/step-by-step.png" alt="Step by step" />
</div>


<p>The renderer and solution working set are unaware of the nitty-gritty details of posts and wires (i.e. the domain rules)
and only focus on showing available options and rendering a world of items.</p>
<p>The commands, world, and <code>RuleEngine</code> on the other hand are unaware of how options are presented or how actions are
triggered. Both the commands and rules are focused on the domain rules for a fixed number of situations or tasks.</p>
<p>All of this runs at the client side of the application, after a command has been executed, the server is updated with
the new version of the world for persistence.</p>
<h3 id="how-did-it-turn-out">How did it turn out?</h3>
<p>This article only used one use-case to illustrate the design. Imagine using the same design for a much more complex
domain, where different subdomains can have their own set of specialized commands.</p>
<p>Our project rendered the world in both 2D and 3D using multiple formats. We managed to reuse the items, view models and
shapes for all 2D rendering (web, PDF- and CAD-files). For 3D, we used separate models for web and STP-files, but the
domain model for items were the same regardless of presentation.</p>
<h3 id="separation-of-concern">Separation of concern</h3>
<p>I think this software design fits these types of programs very well. It brings a clear separation of concern between
the application UI and the domain logic, we opted for dedicated view models and results instead of direct manipulation
which further cements this separation.</p>
<p>The interaction is naturally limited to be action based and one task at a time, making it easier to reason about the
effect of such a task (implemented as a command).</p>
<p>Once a command has been implemented, it is simple to generate different options and have the same command be executed
by a keyboard shortcut, a menu item or an option shown in the drawing (or why not all of them?).</p>
<p>Commands are also composable. When we were tasked to add support for building a long route of posts and wires we
implemented that as a separate command that executed multiple already existing commands to add one post at a time.</p>
<h3 id="testability">Testability</h3>
<p>Testability is great! As stated in the beginning of this article, everyone on the team are avid users of TDD so that
this design turned out to be highly testable was not by accident.</p>
<p>We have component level tests where items, view models or options are the input, and we can assert on details being
present or not in the UI. Commands execution are simple to test given their pure nature.</p>
<p>For the domain logic we have unit-tests for the domain model, such as getting the number of available connections from
a post given its state. Modifying or accessing the world is also simple to unit-test.</p>
<p>The domain rules have slightly more high-level tests that are executed via the <code>SolutionWorkingSet</code> to the <code>RuleEngine</code>
and back. These tests look something like this:</p>
<pre tabindex="0"><code>describe(&#34;extend form post&#34;):
    beforeEach:
        articleRepository = ArticleRepository(&#34;fake-articles.json&#34;)
        workingSet = TestableWorkingSet()
       
    describe(&#34;single post&#34;):
        beforeEach:
            post = workingSet.addPost(&#34;wood&#34;, { x: 0, y: 0, z: 0 })
           
        describe(&#34;when getting options&#34;:
            beforeEach:
                options = workingSet.getOptionsFor(post.id)
               
            test(&#34;should have extend options in all four directions&#34;):
                actual = options.filter(_.command is ExtendFromPost)
                       .map(_.position)
                expect(actual).toEqual([
                    { x: 100, y: 0, z: 0 },  // East
                    { x: 0, y: 0, z: -100 }, // South
                    { x: -100, y: 0, z: 0 }, // West
                    { x: 0, y: 0, z: 100 },  // North
                ])
        
            describe(&#34;execute to the east&#34;):
                beforeEach:
                    val command = option[0].command
                    workingSet.execute(command)
                
                test(&#34;should have added a post&#34;):
                    var posts = workingSet.world.posts()
                    expect(posts.length).toEqual(2)
</code></pre><p>Sure, in the real world there are slightly more details to these tests. I think that the use of options and commands
also benefit the test setup to be quite readable.</p>
<h3 id="performance-and-waste">Performance and waste</h3>
<p>One challenge with this design is that there is some wasted processing when options are evaluated. For options that are
to be shown in the UI all variants are evaluated and options with commands are constructed for all items. This may lead
to quite some allocations which can cause stress on the browser&rsquo;s garbage collector. When debugging or logging, it is
harder to isolate the execution of a single option (without modifying the code) which makes debugging slightly harder.</p>
<p>Our approach here has been to identify where options are slow to generate or when actions are slow to execute and
tackle them case by case doing traditional performance work.</p>
<h3 id="future-improvements">Future improvements</h3>
<p>When we started this project we kept a collaboration mode in the back of our mind. It is not yet realized, but I think
it fits well with the command execution model where the result of an execution can be distributed to other peers.</p>
<p>I think a simple conflict resolution scheme would be sufficient, one where the first to change an item wins. As pointed
out in <a href="https://jamsocket.com/blog/you-might-not-need-a-crdt">this article</a><span class="note">3</span>
 there is a social lock
already. If you visualize where your collaborators are working there is a  natural tendency to not interfere with
others, effectively avoiding conflicts.
<span class="sidenote">
    <a class="no-feedback" href="https://jamsocket.com/blog/you-might-not-need-a-crdt">3.You might not need a CRDT</a>
</span>
</p>
<p>As stated in the beginning of this long article, we wanted product data and rules to be managed as configuration and by
domain experts. Currently, domain experts can easily add or update project data, but they cannot change the business
rules. I believe there is room for improvement here. Maybe some of the rules in the <code>RuleEngine</code> can be expressed in
something more high-level that even the domain experts can be trained to work in, a small domain specific language,
perhaps. Considering how the gaming industry uses scripting languages in combinations with games engines, I think other
businesses could benefit from this way of adjusting the software, if you get it right it would surely amplify the
capabilities of your domain experts.</p>
<p>Thank you for reading! I hope this walkthrough gave you some inspiration or ideas. If you have any thoughts or
questions please <a href="mailto:markus.eliasson@gmail.com">reach out</a>.</p>

        </section>
    </article>

    <footer>
    <h1>Markus Eliasson<span class="is-red-period">.</span></h1>
    <p>A thorough technical lead with a passion for producing valuable and clean code. Tends to occasionally blog about building software and can&#39;t seem to make up his mind on which programming language to use next.</p>
    <p>
        <a href="mailto:markus.eliasson@gmail.com" class="no-feedback">markus.eliasson@gmail.com</a>
    </p>
    <ul class="social">
        
            <li>
                <a href="https://github.com/eliasson" class="no-feedback">
                    <svg class="is-icon"><use xlink:href="#icon-github"></use>"</svg>
                </a>
            </li>
        
            <li>
                <a href="https://x.com/markuseliasson" class="no-feedback">
                    <svg class="is-icon"><use xlink:href="#icon-twitter"></use>"</svg>
                </a>
            </li>
        
            <li>
                <a href="http://www.linkedin.com/in/markuseliasson" class="no-feedback">
                    <svg class="is-icon"><use xlink:href="#icon-linkedin"></use>"</svg>
                </a>
            </li>
        
    </ul>
</footer>

    
<svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
        </symbol>

        <symbol id="icon-linkedin" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect>
            <circle cx="4" cy="4" r="2"></circle>
        </symbol>

        <symbol id="icon-twitter" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
        </symbol>
    </defs>
</svg>
</body>

</html>

